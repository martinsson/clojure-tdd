#Sat Jul 16 23:27:37 CEST 2011
cmdhistory=["(print \\"hello\\")" ";; Loading file src/game_of_life.clj" "(source inc)" "(doc iterate)" "(iterate 3)" "(iterate * 3)" "(iterate + 3)" "(print (iterate * 3))" "(take 4 (iterate * 3))" "(print \\"toto\\")" "(problem1)" ";; Loading file src/euler.clj" "(doc take )" "(println (iterate * 3))" "(println \\"hellooui\\")" "(take 5 (iterate inc))" "(take 5 (iterate inc 2))" "(take 5 (iterate inc 4))" "(take 5 (iterate *3))" "(take 5 (iterate * 3))" "(* 3 4)" "(println (iterate inc))" "(println (iterate inc 1))" "(println \\"hello\\")" "(take 10 (iterate inc 1))" "(take 10 (map \#(* 3 %) (iterate inc 1)))" "(doc range)" "(range 1 100 3)" "(range 3 100 3)" "(problem1)" ";; Loading file src/euler.clj" "(problem1)" "(euler.problem1)" "(euler/problem1)" "(require 'euler)" "(problem1)" "(use 'euler)" "(problem1)" "(doc conj)" "(conj [1 2 3] [3 4 5])" "(doc merge)" "(concat [1 2 3] [3 4 5])" "(problem1)" ";; Loading file src/euler.clj" "(problem1)" ";; Loading file src/euler.clj" "(problem1)" "(union [1 2 3] [3 4 5])" "(set/union [1 2 3] [3 4 5])" "(clojure/set/union [1 2 3] [3 4 5])" "(clojure.set/union [1 2 3] [3 4 5])" "(clojure.set/join [1 2 3] [3 4 5])" ";; Loading file src/euler.clj" "(problem1)" ";; Loading file src/euler.clj" "(problem1)" "(set (concat (range 3 9 3) (range 5 9 5)))" "(set (concat (range 3 10 3) (range 5 10 5)))" ";; Loading file src/euler.clj" "(problem1)" ";; Loading file src/euler.clj" "(problem1)" ";; Loading file src/euler.clj" "(problem1)" ";; Loading file src/euler.clj" "(take 10 (fib))" ";; Loading file src/euler.clj" "(take 10 (fib))" "(take 10 (euler/fib))" ";; Loading file src/euler.clj" "(take 10 (euler/fib))" "(take-while \#(< 4000000) (euler/fib))" "(take-while \#(< 4000000 % ) (euler/fib))" "(take-while \#(< % 4000000 ) (euler/fib))" "(filter even? (take-while \#(< % 4000000 ) (euler/fib)))" ";; Loading file src/euler.clj" "(use 'euler)" ";; Loading file src/euler.clj" "(filter even? (fib-less-than 4000000))" ";; Loading file src/euler.clj" "(euler/problem2)" "(take 15 ((reduce (fn [primes number] (if (nil? (some (partial \= 0) (map (partial mod number) primes))) (conj primes number) primes)) [2] (take 1000 (iterate inc 3)))\\n))" "(take 15 (reduce (fn [primes number] (if (nil? (some (partial \= 0) (map (partial mod number) primes))) (conj primes number) primes)) [2] (take 1000 (iterate inc 3)))\\n)" "(reduce (fn [primes number] (if (nil? (some (partial \= 0) (map (partial mod number) primes))) (conj primes number) primes)) [2] (take 1000 (iterate inc 3)))\\n" "(mod 12 3)" "(div 12 3)" "(doc mod)" "(/\\n  12 3)" "(/\\n  13 3)" "(mod 12 3)" "(\= 0 (mod 12 3))" ";; Loading file src/euler.clj" "(totot)" "(euler/totot)" ";; Loading file src/euler.clj" "(euler/totot)" "(doc reduce)" ";; Loading file src/euler.clj" "(use 'euler)" "(reduce div-if-dividable 600851475143 prime-numbers)" "(reduce div-if-dividable 600851475143 primes-numbers)" "(reduce div-if-dividable 600851475143 (primes-numbers 600851475143))" "(println \\"hellp\\")" "(reduce div-if-dividable 14\\n        (primes-numbers 14))" ";; Loading file src/euler.clj" "(reduce div-if-dividable 14\\n        (primes-numbers 14))" ";; Loading file src/euler.clj" "(euler/problem3\\n  )" ";; Loading file src/euler.clj" "(reduce div-if-dividable 14\\n        (primes-numbers (rounded-root 14)))" "(use 'euler)" "(reduce div-if-dividable 14\\n        (primes-numbers (rounded-root 14)))" ";; Loading file src/euler.clj" "(reduce div-if-dividable 14\\n        (primes-numbers (rounded-root 14)))" ";; Loading file src/euler.clj" "(reduce div-if-dividable 14\\n        (primes-numbers (rounded-root 14)))" "(reduce div-if-dividable 1000\\n        \\n        (primes-numbers (rounded-root 1000)))" ";; Loading file src/euler.clj" "(primes-numbers 100)" "(primes-numbers 1000\\n                )" ";; Loading file src/euler.clj" "(take 100 (primes-numbers))" ";; Loading file src/euler.clj" "(take 100 (primes-numbers))" ";; Loading file src/euler.clj" "(print 3)" ";; Loading file src/euler.clj" "(take 10 (primes))" "(use 'euler)" "(take 10 (primes))" ";; Loading file src/euler.clj" "(take 10 (primes))" ";; Loading file src/euler.clj" "(take 10 (primes))" ";; Loading file src/euler.clj" "(take 10 (lazy-\\n           primes))" "(take 10 (lazy-primes))" "(use 'euler)" "(take 10 (lazy-primes))" ";; Loading file src/euler.clj" "(doc cond)" ";; Loading file src/euler.clj" "jqsjf" ";; Loading file src/euler.clj" "(use 'euler)" "(take 500 (lazy-primes))" ";; Loading file src/euler.clj" "(use 'euler)" "(first lazy-primes)" "(first (lazy-primes))" "(first (next (lazy-primes)))" "(problem3 2 (lazy-primes))" ";; Loading file src/euler.clj" "(use 'euler)" "(probl" "(problem3 37 (lazy-primes))" "(problem3 43\\n          (lazy-primes))" "(problem3 42\\n          (lazy-primes))" "(problem3 12\\n          (lazy-primes))" ";; Loading file src/euler.clj" "(problem3 600851475143 (laz" ")" "(problem3 600851475143 (laz" "(problem3 600851475143 (lazy-primes))" ";; Loading file src/euler.clj" "(time \\n  (problem3 600851475143 (lazy-primes)))" "(time \\n  (problem3 600851475142\\n            (lazy-primes)))" "(time \\n  (problem3 600851475145 (lazy-primes)))" ";; Loading file src/euler.clj" "(time \\n  (problem3 600851475143 (lazy-primes)))" "(time \\n  (problem3 11\\n            (lazy-primes)))" ";; Loading file src/euler.clj" "(time \\n  (problem3 11\\n            (lazy-primes)))" "(time \\n  (problem3 600851475143 (lazy-primes)))" ";; Loading file src/euler.clj" "(time \\n  (problem3 600851475143 (lazy-primes)))" ";; Loading file src/euler.clj" "(time \\n  (problem3 600851475143 (lazy-primes)))" "(time \\n  (problem3 600851475145 (lazy-primes)))" ";; Loading file src/euler.clj" "(time \\n  (problem3 600851475145 (lazy-primes)))" ";; Loading file src/euler.clj" "(time (problem3 600851475143 lazy" "(time (problem3 600851475143 lazy-" "(time (problem3 600851475143 lazy-primes))" "(time (problem3 600851475143 (lazy-primes)\\n                ))" ";; Loading file src/euler.clj" "(time (problem3 600851475143 (lazy-primes)\\n                ))" "(dotimes 10 \\n  (time (problem3 600851475143 (lazy-primes))))" "(doc dotimes)" "(dotimes [toto \\n          10] \\n  (time (problem3 600851475143 (lazy-primes))))" "(time (dotimes [toto 10]  (problem3 600851475143 (lazy-primes))))" "(time (dotimes [toto 100]  (problem3 600851475143 (lazy-primes))))" "(time (dotimes [toto 100]  (problem3 600851475143 (iterate inc))))" "(time (dotimes [toto 100]  (problem3 600851475143 (iterate inc 1))))" "(doc iterate)" "(take 10 (iterate inc 1))" "(time (dotimes [toto 100]  (problem3 37 (iterate inc 1))))" ";; Loading file src/euler.clj" "(problem3 35 '(1 2 3 4 5 6 7) )" ";; Loading file src/euler.clj" "(time (dotimes [toto 100]  (problem3 600851475143 (iterate inc 2))))" " (problem3 600851475143 (iterate inc 2))" ";; Loading file src/euler.clj" "(doc assoc)" "(interleave '(1 2 3) '(4 5 6))" "(\:require clojure.contrib.combinatorics)" "(require clojure.contrib.combinatorics)" "\\n\\nrequire clojure.contrib.combinatorics" ";; Loading file src/euler.clj" "('use clojure.contrib.combinatorics)" "(use 'clojure.contrib.combinatorics)" "(cartesian-product '(1 2 3) '(4 5))" "(map * '(1 2 3) '(4 5))" "(* 999 999)" "(* 999 998\\n   )" "(* 998 998)" "(* 999 997)" "(* 998 997)" ";; Loading file src/euler.clj" "(doc range-" "(doc range)" ";; Loading file src/euler.clj" "(range 3 1)" "(int-array 4)" "(println (int-array 4))" ";; Loading file src/euler.clj" "(cartesian-product '(1 2 3) '(4 5))" "(map (partial apply *) (cartesian-product '(1 2 3) '(4 5)))" ";; Loading file src/euler.clj" "(doc sort)" ";; Loading file src/euler.clj" "(str 678)" "(reverse (str 678))" "(ch" "(chars (str 564))" "(char" "(char-array\\n  (str 564))" "(seq (str 456))" ";; Loading file src/euler.clj" "(some palindrome? (reverse-sort (possible-products 999)))" "(doc some)" "(first (filter palindrome? (reverse-sort (possible-products 999))))" ";; Loading file src/euler.clj" "(doc for)" "(take 100 (for [x (range 100000000) y (range 1000000) \:while (< y x)] [x y]))" ";; Loading file src/euler.clj" "(str (reverse 99\\n              ))" "(str (reverse \\"99\\"))" "\\n(reverse \\"99\\")" "\\n(reverse \\"98\\")" ";; Loading file src/euler.clj" "(doc int)" "(int \\"3\\")" "(Integer/valueOf \\"3\\")" ";; Loading file src/euler.clj" "(complement -)" "((complement -) 1 2)" "(find-doc opposite)" "(find-doc \\"\\nopposite\\")" "(find-doc \\"opposite\\")" "(find-doc \\"desc\\")" "(take 10 (iterate - 1))" "(- 1)" "(- -1)" ";; Loading file src/euler.clj" "(for [x (reverse (range 100 1000))] when (zero? (mod 1000 x)))" "(for [x (reverse (range 100 1000))] \:when (zero? (mod 1000 x)))" "(for [x (reverse (range 100 1000)) \:when (zero? (mod 1000 x))])" "(for [x (reverse (range 100 1000)) \:when (zero? (mod 1000 x))] x)" "(for [x (reverse (range 100 1000)) \:when (zero? (mod 10000 x))] x)" "(for [x (reverse (range 100 1000)) \:when (zero? (mod 50000 x))] x)" "(for [x (reverse (range 100 1000)) \:when (zero? (mod 1000000 x))] x)" ";; Loading file src/euler.clj" "(three-digit-divisors-of 10000)" ";; Loading file src/euler.clj" "(three-digit-divisors-of 10000)" "(first (map three-digit-divisors-of (palindromes 1000)))" ";; Loading file src/euler.clj" "(first (map three-digit-divisors-of (palindromes 1000)))" ";; Loading file src/euler.clj" "(first (map three-digit-divisors-of (palindromes 1000)))" ";; Loading file src/euler.clj" "(first (map three-digit-divisors-of (palindromes 1000)))" ";; Loading file src/euler.clj" "(first (map three-digit-divisors-of (palindromes 1000)))" "(ffirst (map three-digit-divisors-of (palindromes 1000)))" "(first (flatten (map three-digit-divisors-of (palindromes 1000))))" "(first (map three-digit-divisors-of (palindromes 1000)))" "(first (filter not-empty (map three-digit-divisors-of (palindromes 1000))))" "(ffirst (filter not-empty (map three-digit-divisors-of (palindromes 1000))))" "(time (ffirst (filter not-empty (map three-digit-divisors-of (palindromes 1000)))))" ";; Loading file src/euler.clj" "(euler/problem4-fast)" "(first (filter palindrome? (possible-products 1000))" "(first (filter palindrome? (possible-products 1000)))" "(first (filter palindrome? (reverse-sort (possible-products 1000))))" ";; Loading file src/euler.clj" "(euler/problem4-slow)" ";; Loading file src/euler.clj" "(euler/problem4-slow)" "(doc dec)" "(take 100 (dec 10))" "(take 100 (iterate dec 10))" "(take-while (> 0) (iterate dec 10))" "(take-while \#(> 0) (iterate dec 10))" "(take-while \#(> % 0) (iterate dec 10))" "(take-while pos? (iterate dec 10))" "(source range)" "(range 10 1 -1)" "(apply max (filter \#(\= (str %) (apply str (reverse (str %))))\\n               (for [x (range 100 1000) y (range 100 x)] (* x y))))" "(apply max (filter \#(\= (str %) (apply str (reverse (str %))))\\n               (for [x (range 1000 100 -1) y (range x 100 -1)] (* x y))))" "(first (filter \#(\= (str %) (apply str (reverse (str %))))\\n               (for [x (range 1000 100 -1) y (range x 100 -1)] (* x y))))" "(first \\n               (for [x (range 1000 100 -1) y (range x 100 -1) \:when  \#(\= (str %) (apply str (reverse (str %))))]  (* x y)))" "(let [products\\n      (for [a (range 100 1000)\\n            b (range 100 a)]\\n        (* a b))]\\n  (reduce max (filter palindrome? products)))" "(defn p4-1 [digits]        ;; a quick solution, note a-b? doesn't traverse all range\\n  (let [lb        (math/expt 10 (dec digits))            ;; lower bound\\n        ub        (math/expt 10 digits)                ;; upper bound\\n        rs        (range (* ub ub) (* lb lb) -1)    \\n        pal?    (fn [x]                            ;; is number palindrome?\\n                   (let [str-x    (str x)]\\n                     (\= str-x (str/reverse str-x))))\\n        pa        (filter pal? rs)        ;; filters out palindrome numbers\\n           a-b?     (fn    [x, digits]            ;; is x \= a * b, where count(a, b) \= digits?                 \\n                              (let [guess        (math/ceil (math/sqrt x))]    ;; * initial guess at sqrt *\\n                                (loop [a    guess]\\n                                  (cond\\n                                    (> a (Math/pow 10 digits))    nil\\n                                    (zero? (rem x a))                        (list x)\\n                               \:else                                                (recur (inc a))))))]\\n    (first (drop-while nil? (map \#(a-b? % digits) pa)))))" "(use 'clojure.contrib.math)" "(defn p4-1 [digits]        ;; a quick solution, note a-b? doesn't traverse all range\\n  (let [lb        (math/expt 10 (dec digits))            ;; lower bound\\n        ub        (math/expt 10 digits)                ;; upper bound\\n        rs        (range (* ub ub) (* lb lb) -1)    \\n        pal?    (fn [x]                            ;; is number palindrome?\\n                   (let [str-x    (str x)]\\n                     (\= str-x (str/reverse str-x))))\\n        pa        (filter pal? rs)        ;; filters out palindrome numbers\\n           a-b?     (fn    [x, digits]            ;; is x \= a * b, where count(a, b) \= digits?                 \\n                              (let [guess        (math/ceil (math/sqrt x))]    ;; * initial guess at sqrt *\\n                                (loop [a    guess]\\n                                  (cond\\n                                    (> a (Math/pow 10 digits))    nil\\n                                    (zero? (rem x a))                        (list x)\\n                               \:else                                                (recur (inc a))))))]\\n    (first (drop-while nil? (map \#(a-b? % digits) pa)))))" "(require 'clojure.contrib.math)" "(defn p4-1 [digits]        ;; a quick solution, note a-b? doesn't traverse all range\\n  (let [lb        (math/expt 10 (dec digits))            ;; lower bound\\n        ub        (math/expt 10 digits)                ;; upper bound\\n        rs        (range (* ub ub) (* lb lb) -1)    \\n        pal?    (fn [x]                            ;; is number palindrome?\\n                   (let [str-x    (str x)]\\n                     (\= str-x (str/reverse str-x))))\\n        pa        (filter pal? rs)        ;; filters out palindrome numbers\\n           a-b?     (fn    [x, digits]            ;; is x \= a * b, where count(a, b) \= digits?                 \\n                              (let [guess        (math/ceil (math/sqrt x))]    ;; * initial guess at sqrt *\\n                                (loop [a    guess]\\n                                  (cond\\n                                    (> a (Math/pow 10 digits))    nil\\n                                    (zero? (rem x a))                        (list x)\\n                               \:else                                                (recur (inc a))))))]\\n    (first (drop-while nil? (map \#(a-b? % digits) pa)))))" "(require 'clojure.contrib.mah)" "(defn makepalindrome [n]\\n  (Integer. (apply str (concat (seq (str n)) (reverse (seq (str n)))))))\\n \\n(defn getsol [pal]\\n  (loop [d 999]\\n    (if (zero? (mod pal d))\\n      (if (> 1000 (/ pal d))\\n        [d (/ pal d)]\\n        [])\\n      (recur (dec d)))))\\n \\n(loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))\\n " "(time (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n)))))" "(time (dotimes 100 (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))))" "(time (dotimes [100] (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))))" "(time (dotimes [toto 100] (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))))" "(time (dotimes [toto 100] (defn problem4-fast []\\n  (ffirst (filter not-empty (map three-digit-divisors-of (palindromes 1000)))))))" "(time (dotimes [toto 100] (problem4-fast)))" "(time (dotimes [toto 100] (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))))" "(defn makepalindrome [n]\\n  (Integer/valueOf (apply str (concat (seq (str n)) (reverse (seq (str n)))))))" "(time (dotimes [toto 100] (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))))" "(defn makepalindrome [n]\\n  (Integer. (apply str (concat (seq (str n)) (reverse (seq (str n)))))))" "(time (dotimes [toto 100] (loop [n 997]\\n  (def pal (makepalindrome n))\\n  (def sol (getsol pal))\\n  (if (not-empty sol)\\n    [pal sol]\\n    (recur (dec n))))))" ";; Loading file src/euler.clj" "(problem4-fast)" ";; Loading file src/euler.clj" "(reduce rest-after-div-by [1 2 3])" "(doc reduce)" ";; Loading file src/euler.clj" "(reduce / 6 '(1 2 3))" "(reduce / 12\\n        '(1 2 3))" "(reduce / 12 '(1 2 3 4))" "(reduce \#(if (divisable-by? %1 %2)\\n           (/ %1 %2)\\n           %1) 12 '(1 2 3 4))" "(reduce \#(if (divisable-by? %1 %2)\\n           (/ %1 %2)\\n           %1) 24 '(1 2 3 4))" "(reduce \#(if (divisable-by? %1 %2)\\n           (/ %1 %2)\\n           %1) 15 '(1 2 3 4))" "(doc conj)" "(doc cons)" ";; Loading file src/euler.clj" "(reduce cumulated-divisors (range 21))" ";; Loading file src/euler.clj" "(smallest-number-evenly-divisable-by (range 1 21))" "(doc mod)" "(mod 7 3)" "(rem 7 3)" "(doc rem)" "(mod 9 3)" "(rem 9 3)" "(\\n  mod -9 3)" "(\\n  rem -9 3)" "(smallest-number-evenly-divisable-by (range 1 21))" "(time (dotimes [tata 100] (smallest-number-evenly-divisable-by (range 1 21))))" ";; Loading file src/euler.clj" "(- (square-of-sum 100) (sum-of-squares 100))" "(defn square [x] (* x x))\\n(defn cube [x] (* x x x))\\n \\n;; Square of sums is equivalent to square of the cubes.\\n(defn square-of-sums [n]\\n  (reduce + (map cube (range (inc n)))))\\n \\n(defn sum-of-squares [n]\\n  (reduce + (map square (range (inc n)))))\\n \\n(- (square-of-sums 100) (sum-of-squares 100))" ";; Loading file src/euler.clj" ";; Loading file src/primes.clj" "(nth 1 (lazy-primes))" "(doc nth)" "(nth (lazy-primes) 1\\n     )" "(nth (lazy-primes) 0)" "(nth (lazy-primes) 10000)" "(time (dotimes [totot 100] (nth (lazy-primes) 10000)))" "(reduce + (take-while \#(< % 2000000) (lazy-primes)))" "(time \\n  (reduce + (take-while \#(< % 2000000) (lazy-primes))))" "(doc take)" "(doc take-while)" "(time \\n  (reduce + (for [x (lazy-primes) \:while (< x 2000000)] [x]\\n              )))" "(doc for)" "(reduce + (for [x (lazy-primes) \:while (< x 2000000)] x))" "(time (reduce + (for [x (lazy-primes) \:while (< x 2000000)] x)))" "(nth (lazy-primes) 10000)" "(nth (lazy-primes) 100000)" "(nth (lazy-primes) 1000000)" "(doc permutations)" "(count (permutations (range 10) ))" ";; Loading file src/primes.clj" "(doc some" "(doc some)" ";; Loading file src/primes.clj" "(doc memoize)" " (permutations (range 4) )" " (concat (permutations (range 4) ))" " (apply concat (permutations (range 4) ))" " (map concat (permutations (range 4) ))" " (map str (permutations (range 4) ))" " (map (partial apply str) (permutations (range 4) ))" " (map (partial apply str) (permutations (range 0 4 -1) ))" " (map (partial apply str) (permutations (range 4 0 -1) ))" " (map (-> apply str) (permutations (range 4 0 -1) ))" " (map (-> str apply) (permutations (range 4 0 -1) ))" " (map (partial apply str) (permutations (range 4 0 -1) ))" " (map (-> (partial apply str) Integer.) (permutations (range 4 0 -1) ))" " (map (-> (partial apply str) Integer/valueOf) (permutations (range 4 0 -1) ))" " (map (partial apply str) (permutations (range 4 0 -1) ))" " (map \#(Integer. (apply str %)) (permutations (range 4 0 -1) ))" " (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) ))" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) )))" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) ))))" ";; Loading file src/primes.clj" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) ))))" "(use primes')" "(use '\\n      primes)" "(use 'primes)" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) ))))" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 5 -1 -1) ))))" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 3 -1 -1) ))))" "(permutations (range 3 -1 -1) )" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 2 -1 -1) ))))" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) ))))" "(map \#(Integer. (apply str %)) (permutations (range 2 -1 -1) ))" "(first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) ))))" "(time (first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) )))))" ";; Loading file src/primes.clj" "(time (first (filter prime? (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) )))))" ";; Loading file src/primes.clj" "(time (first (filter (partila prime? lazy-primes) (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) )))))" "(time (first (filter (partial prime? lazy-primes) (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) )))))" "(time (first (filter (partial prime? (memoize lazy-primes)) (map \#(Integer. (apply str %)) (permutations (range 4 -1 -1) )))))" "(time (first (filter (partial prime? (memoize lazy-primes)) (map \#(Integer. (apply str %)) (permutations (range 5 -1 -1) )))))" "(count (permutations (range 10)))" "(doc permutations)" "(first (permutations (range 10)))" "(time (problem41 4))" ";; Loading file src/primes.clj" "(time (problem41 4))" "(use 'primes)" "(time (problem41 4))" ";; Loading file src/primes.clj" "(time (problem41 4))" ";; Loading file src/primes.clj" "(time (problem41 4))" "(time (problem41 5))" "(time (problem41 6))" ";; Loading file src/primes.clj" "(reduce + (range 10))" "(reduce + (range 4))" "(reduce + (range 5))" "(reduce + (range 6))" "(reduce + (range 7))" "(reduce + (range 8))" "(time (problem41 7))" ";; Loading file src/primes.clj" "(use 'primes)" "(reduce + (range 8))" "(reduce + (range 9))" "(reduce + (range 10))" "(reduce + (range 1 10))" "(reduce + (range 1 8))" "(reduce + (range 1 7))" "(reduce + (range 1 6\\n                 ))" "(reduce + (range 1 6))" "(reduce + (range 1 5))" "(range 1 5)" "(problem41 4)" ";; Loading file src/primes.clj" "(problem41 4)" ";; Loading file src/primes.clj" "(problem41 4)" ";; Loading file src/primes.clj" "(problem41 4)" "(doc max)" ";; Loading file src/primes.clj" "(problem41 4)" ";; Loading file src/primes.clj" "(for [x (range 10)] (reduce + (range (inc x))))" "(for [x (range 10)] [x (reduce + (range (inc x)))])" "(first (permutations (range 7 0 -1) ))" "(first (map \#(Integer. (apply str %)) (permutations (range 7 0 -1) )))" "(problem41 4)" "(time (problem41 4))" ";; Loading file src/primes.clj" "(problem41 4)" "(time (problem41 4))" ";; Loading file src/primes.clj" ";; Loading file src/euler_common.clj" ";; Loading file src/primes.clj" ";; Loading file src/euler.clj" ";; Loading file src/primes.clj" "(time (problem41 4))" "(time (problem41 7))" "(defn pandigital?\\n  [n]\\n  (\= (apply sorted-set (map \#(Integer. (str %)) (str n)))\\n     (apply sorted-set (map \#(Integer. %) (range 1 (inc (count (str n))))))))" "(reduce max\\n           (filter \#(and (prime? %) (pandigital %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7]))))" "(use 'primes)" "(reduce max\\n           (filter \#(and (prime? %) (pandigital %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7]))))" "(reduce max\\n           (filter \#(and (prime? %) (pandigital? %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7]))))" "(defn euler-41\\n  []\\n   (reduce max\\n           (filter \#(and (prime? %) (pandigital? %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7])))))" "(euler-41)" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" ";; Loading file src/primes.clj" "(time (problem41 7))" "(time (dotimes [100 100] (problem41 7)))" "(time (dotimes [toto 100] (problem41 7)))" "(time (dotimes [toto 1000] (problem41 7)))" ";; Loading file src/primes.clj" "(time (dotimes [toto 1000] (problem41 7)))" "(time (problem41 8))" "(time (problem41 9))" "(use '[clojure.contrib.lazy-seqs \:only (primes)]\\n     '[clojure.contrib.combinatorics \:only (permutations)])\\n \\n(defn prime? [n]\\n  (not-any? \#(zero? (rem n %)) (take-while \#(<\= (* % %) n) primes)))\\n \\n(defn as-int [coll]  (Integer/parseInt (apply str coll)))\\n \\n(defn euler-41 [s]\\n  (first (filter \#(prime? (as-int %))\\n                      (lazy-cat (permutations s)\\n                                [(euler-41 (rest s))]))))\\n \\n(time (euler-41 \\"987654321\\"))" "(doc lazy-cat)" "(defn prime? [n]\\n  (not-any? \#(zero? (rem n %)) (take-while \#(<\= (* % %) n) (iterate inc 2))))" "(time (euler-41 \\"987654321\\"))" "(defn prime? [n]\\n  (not-any? \#(zero? (rem n %)) (take-while \#(<\= (* % %) n) primes)))" "(time (euler-41 \\"987654321\\"))" "(time (dotimes [toto 1000] (problem41 7)))" "(time (problem41 8))" "(time (problem41 9))" ";; Loading file src/primes.clj" "(time (problem41 9))" "(defn pandigital?\\n  [n]\\n  (\= (apply sorted-set (map \#(Integer. (str %)) (str n)))\\n     (apply sorted-set (map \#(Integer. %) (range 1 (inc (count (str n))))))))\\n \\n(defn permutations\\n  \\"Returns a lazy seq of all permutations of a seq\\"\\n  [x]\\n  (if (seq x)\\n    (mapcat\\n     (fn [[f & r]]\\n       (map \#(cons f %) (permutations r)))\\n     (rotations x))\\n    (list nil)))\\n \\n(defn euler-41\\n  []\\n   (reduce max\\n           (filter \#(and (prime? %) (pandigital %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7])))))" ";; Loading file src/primes.clj" "(defn pandigital?\\n  [n]\\n  (\= (apply sorted-set (map \#(Integer. (str %)) (str n)))\\n     (apply sorted-set (map \#(Integer. %) (range 1 (inc (count (str n))))))))\\n \\n(defn permutations\\n  \\"Returns a lazy seq of all permutations of a seq\\"\\n  [x]\\n  (if (seq x)\\n    (mapcat\\n     (fn [[f & r]]\\n       (map \#(cons f %) (permutations r)))\\n     (rotations x))\\n    (list nil)))\\n \\n(defn euler-41\\n  []\\n   (reduce max\\n           (filter \#(and (prime? %) (pandigital %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7])))))" "(use 'primes)" "(defn pandigital?\\n  [n]\\n  (\= (apply sorted-set (map \#(Integer. (str %)) (str n)))\\n     (apply sorted-set (map \#(Integer. %) (range 1 (inc (count (str n))))))))\\n \\n(defn permutations\\n  \\"Returns a lazy seq of all permutations of a seq\\"\\n  [x]\\n  (if (seq x)\\n    (mapcat\\n     (fn [[f & r]]\\n       (map \#(cons f %) (permutations r)))\\n     (rotations x))\\n    (list nil)))\\n \\n(defn euler-41\\n  []\\n   (reduce max\\n           (filter \#(and (prime? %) (pandigital %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7])))))" "(defn euler-41\\n  []\\n   (reduce max\\n           (filter \#(and (prime? %) (pandigital? %))\\n                           (map \#(Integer/parseInt (apply str %))\\n                                (permutations [1 2 3 4 5 6 7])))))" "(euler-41)" "(time (euler-41))" "(problem41 7)" "(time (dotimes [toto 1000] (problem41 7)))" ";; Loading file src/primes.clj" "(time (dotimes [toto 100] (problem41 7)))" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" "\\n(problem41 \\"7654321\\")" "\\n(time (problem41 \\"7654321\\"))" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" "(take 15 (cons 2 (iterate inc 3)))" "(take 15 (cons 2 (iterate inc 3 2)))" "(doc inc)" "(source range)" "(doc comp)" ";; Loading file src/primes.clj" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" ";; Loading file src/primes.clj" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" ";; Loading file src/primes.clj" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" ";; Loading file src/primes.clj" "(cons 2 (range 3 (sqrt 2) 2))" ";; Loading file src/primes.clj" "(cons 2 (range 3 (sqrt 2) 2))" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" ";; Loading file src/primes.clj" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))" ";; Loading file src/primes.clj" "(time (dotimes [toto 100] (problem41 \\"7654321\\")))"]
eclipse.preferences.version=1
